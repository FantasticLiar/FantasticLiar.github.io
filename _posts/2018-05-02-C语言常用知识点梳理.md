---
layout: post
title:  "c语言常用知识点梳理"
categories: C语言
tags:  c知识点梳理
author: fantastic_liar
---
* content
{:toc}
c语言常用知识点：

#### 知识点1:交换两个变量值的方法
* 采用第三方变量(最容易想到的方法)
* 采用加减法进行值得交换（面试时常用**）

代码如下：
```
b = a - b;
a = a - b;
b = a + b;
```
采用按位异或的位方式

代码如下：
```
a = a^b;
b = a^b;
a = a^b;
```




#### 知识点2:(\*p)[3]与\*p[3]的区别
因为[]的优先级高于\*,所以结合顺序不一样，所表示的含义也不一样。

* (\*p)[3]：p先和\*结合，表示p是一个指针，然后和[3]结合，表示指向一个维度为3的数组，合起来的意思就是p指向一个n行3列的二维数组。

* \*p[3]:p先个[3]结合，表示p是一个数组，然后再和\*结合，表示里面存的是指针，合起来的意思就是p是一个3行的数组，数组里面存的指针。

#### 知识点3:sizeof的使用
* sizeof是一种运算符不要想当然理解为函数
* sizeof使用时可以不加()
* sizeof可以加变量、常量、数据类型
* 跟数据类型是必须加()

#### 知识点4:#include编译预处理命令与多文件团队开发
* include编译预处理命令可以认为是：将后面的文件内容拷贝到当前的文件中
* 多文件团队开发：模块分别编译成.o都不能链接成功，合起来链接生成最终程序。
* 链接：把项目中所有相关联的.o目标文件、C语言函数库合并在一起，生成可执行文件
* 函数的定义放.c文件，函数的声明放.h文件
* 如果要使用某个.c文件中定义的函数，只需要#include这个.c文件对应的.h文件
* h文件的作用：被别人拷贝。编译链接的时候不需要管.h文件

#### 知识点5:数组的几种初始化方式如下
```
int a[3] = {10, 9, 6};
int a[3] = {10,9};
int a[] = {11, 7, 6};
int a[4] = {[1]=11,[0] = 7};（知道有此种初始化方式即可）
```
#### 知识点6:数组的内存分析和注意点
* 存储空间的划分（内存的分配是从高地址到低地址进行的，但一个数组内部元素又是从低到高进行的）【注：对于以后学习重要】
* 数组名的作用，查看元素地址
* 注意数组不要越界
#### 知识点7:字符串知识点
* "123”其实是由'1'、'2'、'3'、'\0'组成
* 字符串的输出"%s"，'\0'是不会输出的

#### 知识点8:字符串处理函数:strlen()
* 计算的是字符数，不是字数
* 计算的字符不包括'\0'，一个汉字相当于3个字符

例子："哈haha" 字符数为7

### 指针部分：

#### 知识点9：指针定义的格式
变量类型 *变量名

如 int *p
#### 知识点10：指针作用
能够根据一个地址值，访问对应的存储空间

例：
```
int *p;
int a = 90;
P = &a;
*p = 10;//把10赋值给p所指的存储空间
```
#### 知识点11：指针使用注意
* int *p只能指向int类型的数据
* 指针变量只能存储地址
* 指针变量未经初始化不要拿来间接访问其他存储空间
#### 知识点12：指针与数组
遍历数组
```
    int ages[5] = {10, 4, 9, 44, 99};
    for(int i = 0; i<5; i++){
        printf("%d\n", ages[i]);
    }
```
使用指针遍历数组：
```
    int *p;// 指针变量P指向了数组的首地址
    p = &ages[0];// 使用指针遍历数组
    for(int i =  0; i<5; I++){
        printf("ages[%d] = %d\n", i, *(p + i));
    }
```
* 注：指针+ 1取决于指针的类型
* 注：数组的访问方式
    1. 数组名[下标]
    2. 指针变量名[下标]
    3. *(p+i)
#### 知识点13：指针与字符串
定义字符串的两种方式
1. 利用数组
    char name[] = "Andyzhao"

    特点：字符串里的字符可以修改

    适用场合：字符串内容需要经常修改

2. 利用指针

    char *name = "itcast"

    特点：字符串是一个常量，字符串里面的字符不能修改

    使用场合：字符串的内容不需要修改，而这个字符串经常使用

#### 知识点13：预处理指令（三种）：
* 宏定义
* 条件编译
* 文件包含
* 宏定义的配对使用和带参数的宏
带参数的宏
```
 # define sum(v1,v2) ((v1) + (v2))//括号是必须的
```
例如：
```
#define pingfang1(a) a*a
#define pingfang2(a) (a*a)
想想，为什么结果为不一样呢？？
pingfang1(4)/pingfang1(2)//结果为16
pingfang2(4)/pingfang2(2)//结果为4
```
* 带参数的宏效率比函数高
* 条件编译(一般是判断宏的值)
```
#if 条件
...
#elif 条件
...
#else
...
#endif(非常重要)不然后面的代码全部无效
```
* 文件包含
<>表示系统自带的文件，""表示自定义文件

不允许循环包含，比如a.h包含b.h，b.h又包含a.h

#### 知识点14：typedef 只是给类型起了个别名并不是定义新类型
```
  struct Student{
    int age;
    char *name;
    };
    typedef struct Student Student;
    等价于
    typedef struct Student{
    int age;
    char *name;
    }Student;
也等价于
    typedef struct {
    int age;
    char *name;
    }Student;
```
类似的给枚举类型起名
```
 typedef enum Sex{
        Man,Women
    }Sex;
```
* 下面这种情况的写法比较特殊
```
//下面是函数指针类型的自定义数据类型,返回值类型和参数类型要匹配
#include
    typedef int (*TypeFuncPointer)(int, int);
    int add(int a, intb){
        return a + b;
    }
    int minus(int a, intb){
        return a - b;
    }
    int main(){
        TypeFuncPointer p = add;//使用自定义类型Î
        TypeFuncPointer p2 = minus;//使用自定义类型Î
        printf("add = %d\n",p(1, 2));
        printf("minus = %d\n",p2(1, 2));
        return 0;
    }
```

下面是定义结构体的指针类型
```
  typedef struct Student{
    int age;
    char *name;
    }*PtrStu;
    //使用方式
    Student stu ={18, "zhangsan"};
    PtrStu p = &stu;
```
宏定义也是可以为类型起名的
```
#define Integer int
```
相当于
```
typedef int Integer
```
注意和typedef的区别
例如：
```
typedef char * String
#define String char *
```

#### 知识点15：static和extern区别是能否进行跨文件访问
1. 函数
2. 变量

对函数的作用

外部函数：定义的函数能被本文件和其他文件访问
内部函数；定义的函数只能被本文件访问
默认情况下，所有函数都是外部函数（相当于带关键字extern）,所以可以省略extern作用：

完整的定义和引用一个外部函数都加extern

引用时也是默认是外部函数所以也省略extern

static作用：定义一个内部函数

使用：static返回类型函数名(参数列表)

不能被其他文件调用

一个项目中，本文件的外部函数名不能和其他文件的外部函数同名(error)

本文件中的内部函数(static)可以和其他文件的函数名同名的

对变量的作用：

全局变量分为两种：

外部变量：定义的变量可以被其他文件访问

1. 默认情况下所有的全局变量都是外部变量
2. 不同文件中的同名外部变量都代表同一个
3. 定义一个外部变量不加extern，声明才加extern

同样的声明是没有错误的

内部变量：定义的变量不能被其他文件访问

不同文件的同名内部变量互不影响